<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projektowanie aplikacji</title>
    <link rel="shortcut icon" href="Images/Icon/icon.webp" type="image/x-icon"">
    <!--Style-->
    <link rel="stylesheet" href="Style/style.css">
    <link rel="stylesheet" href="Style/nav.css">
    <link rel="stylesheet" href="Style/main.css">
    <link rel="stylesheet" href="Style/footer.css">
    <link rel="stylesheet" href="Style/praktyki.css">
    <link rel="stylesheet" href="Style/cleancode.css">
    <link rel="stylesheet" href="Style/dokumentowaniekodu.css">
    <link rel="stylesheet" href="Style/algorytmy.css">
    <link rel="stylesheet" href="Style/projektowanieklas.css">
</head>
<body>
    <nav>
        <ul>
        <button onclick="scrollToSection('Praktyki')">Dobre Praktyki</button>
        <button onclick="scrollToSection('CleanCode')">Clean Code</button>
        <button onclick="scrollToSection('DokumentowanieKodu')">Dokumentowanie kodu</button>
        <button onclick="scrollToSection('Algorytmy')">Algorytmy</button>
        <button onclick="scrollToSection('ProjektowanieKlas')">Projektowanie klas (UML)</button>
        </ul>
    </nav>
    <main>
        <div id="Praktyki">
                <h1>Dobre Praktyki</h1>
            <div id="PraktykiList">
                <ul>
                    <li><mark class="hover-target" data-image="Images/Praktyki/Enkapsulacja.png"><b>Enkapsulacja</b></mark> = Ukrywanie szczegółów implementacji wewnątrz klasy, aby chronić dane przed nieautoryzowanym dostępem. Dzięki temu, dane są bezpieczniejsze, a kod bardziej niezawodny.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Dziedziczenie.png"><b>Dziedziczenie</b></mark> = Umożliwia tworzenie nowych klas na podstawie już istniejących, co pozwala na ponowne wykorzystanie kodu i rozszerzanie funkcjonalności bez jego powtarzania.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Polimorfizm.png"><b>Polimorfizm</b></mark> = Pozwala na definiowanie metod o tej samej nazwie, ale o różnych implementacjach w różnych klasach, zwiększając elastyczność kodu.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/ZasadaJednejOdpowiedzialnosci.png"><b>Zasada Jednej Odpowiedzialności</b></mark> = Klasa powinna odpowiadać tylko za jeden aspekt działania aplikacji, co ułatwia jej zrozumienie i modyfikację.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Odwrocenie_zalezności.png"><b>Odwrócenie zależności</b></mark> = Klasy wyższego poziomu powinny zależeć od abstrakcji, a nie od szczegółów implementacyjnych, co poprawia elastyczność i testowalność.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Interfejsy_i_abstrakcje.png"><b>Interfejsy i abstrakcje</b></mark> = Pozwalają na definiowanie wspólnych zasad działania, które muszą być zaimplementowane przez różne klasy, co ułatwia rozszerzanie kodu.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Unikanie_Dupikacji.png"><b>Unikanie duplikacji kodu</b></mark> = Ważne jest unikanie powtarzania tej samej logiki, ponieważ zmniejsza to złożoność kodu i upraszcza jego utrzymanie.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Testowanie_jednostkowe.png"><b>Testowanie jednostkowe</b></mark> = Pomaga upewnić się, że każda część kodu działa poprawnie i zgodnie z oczekiwaniami, zapewniając stabilność aplikacji.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Projektowanie_rozszerzalnosci.png"><b>Projektowanie z myślą o rozszerzalności</b></mark> = Tworzenie kodu w taki sposób, aby łatwo było dodawać nowe funkcjonalności bez wprowadzania zmian w istniejącej logice.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Loose_Coupling.png"><b>Unikanie zbytniego powiązania klas (Loose Coupling)</b></mark> = Klasy powinny być jak najmniej zależne od siebie, co pozwala na łatwiejsze modyfikacje i testowanie.</li>
                </ul>
            </div>
        </div>
        <div id="CleanCode">
            <h1>Clean Code</h1>
            <div class="card-container">
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>KISS</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Keep It Simple, Stupid" = rozwiązania powinny być proste, unikaj nadmiernej komplikacji.
                            </p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>DRY</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Don't Repeat Yourself" = nie duplikuj kodu; każda informacja w systemie powinna mieć jedno źródło.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>YAGNI</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"You Aren't Gonna Need It" = implementuj tylko te funkcje, które są naprawdę potrzebne, unikaj nadmiernego rozwijania kodu.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>SOLID</p>
                        </div>
                        <div class="flip-card-back">
                            <ul style="font-size: 14px;">
                                <li>S = Single Responsibility Principle</li>
                                <li>O = Open/Closed Principle</li>
                                <li>L = Liskov Substitution Principle</li>
                                <li>I = Interface Segregation Principle</li>
                                <li>D = Dependency Inversion Principle</li>
                            </ul>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>TDD</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Test-Driven Development" = rozwój oparty na testach; najpierw pisz testy, a potem kod, aby zapewnić jakość i poprawność.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>SRP</p>
                        </div>
                        <div class="flip-card-back">
                            <p style="font-size: 15px;">"Single Responsibility Principle" = zasada jednej odpowiedzialności, czyli każda klasa lub funkcja powinna mieć jedną, jasno określoną odpowiedzialność.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="DokumentowanieKodu">
            <h1>Dokumentowanie Kodu</h1>
            <div>
                <h2><b>Definicja</b></h2>
                <h3 style="font-size: 17px;"><b>Dokumentowanie</b> kodu jest niezwykle ważnym elementem tworzenia oprogramowania, który pomaga programistom (i przyszłym użytkownikom) lepiej zrozumieć, jak działa kod oraz w jaki sposób go używać. Dzięki dobrze napisanej dokumentacji, zrozumienie kodu, jego modyfikacja oraz naprawa ewentualnych błędów stają się o wiele prostsze.</h3>
                <h2><b>Dlaczego warto dokumentować kod?</b></h2>
                <ul>
                    <li><b>Zrozumiałość</b> = Dokumentacja pomaga zrozumieć kod zarówno innym programistom, jak i nam samym w przyszłości, gdy będziemy do niego wracać.</li>
                    <li><b>Łatwiejsze utrzymanie</b> = Ułatwia znalezienie miejsc, które wymagają poprawy lub rozbudowy.</li>
                    <li><b>Przejrzystość</b> = Przejrzysta dokumentacja usprawnia pracę zespołową oraz wdrażanie nowych osób do projektu.</li>
                    <li><b>Profesjonalizm</b> = Dobrze udokumentowany kod świadczy o profesjonalnym podejściu do programowania.</li>
                </ul>
                <h2><b>Rodzaje dokumentacji</b></h2>
                    <ul>
                        <h3><mark class="hover-target" data-image="Images/Dokumentacja/Techniczna.png"><b>Dokumentacja techniczna</b></mark></h3>
                        <li>Dokumentacja API</li>
                        <li>Diagramy UML</li>
                        <li>Opis architektury</li>
                        <li>Instrukcje instalacji i wdrożenia</li>
                        <li>Lista błędów i sposobów ich obsługi</li>
                    </ul>
                    <ul>
                        <h3><mark class="hover-target" data-image="Images/Dokumentacja/Uzytkowa.png"><b>Dokumentacja użytkowa</b></mark></h3>
                            <li>Instrukcje obsługi</li>
                            <li>FAQ</li>
                            <li>Poradniki i tutoriale</li>
                            <li>Przykłady użycia i scenariusze</li>
                            <li>Materiały szkoleniowe</li>
                    </ul>                
            </div>
        </div>
        <div id="Algorytmy">
            <h1>Algorytmy</h1>
            <div>
                <h2><b>Czym jest algorytm?</b></h2>
                <h3 style="font-size: 17px;"><b>Algorytm</b> to skończony zestaw dobrze zdefiniowanych instrukcji lub kroków, które należy wykonać w określonej kolejności, aby rozwiązać problem lub osiągnąć określony cel. Algorytmy są fundamentem programowania i są używane w wielu dziedzinach, takich jak matematyka, informatyka czy automatyka.</h3>
                <h2><b>Projektowanie algorytmu</b></h2>
                    <ul>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Dziel.png"><b>Zasada „dziel i zwyciężaj”</b></mark> = Technika projektowania algorytmów polegająca na podziale problemu na mniejsze podproblemy, rozwiązaniu ich niezależnie, a następnie scaleniu wyników w rozwiązanie główne.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/ListaKrokow.png"><b>Lista kroków</b></mark> = Sekwencja kroków definiująca algorytm w logicznej kolejności.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Pseudokod.png"><b>Pseudokod</b></mark> = Opis algorytmu w zrozumiałej formie, przypominający kod, ale bardziej ogólny.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Drzewo.png"><b>Drzewo decyzyjne</b></mark> = Graficzna reprezentacja algorytmu, opisująca decyzje i ich konsekwencje.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Blokowy.png"><b>Schemat blokowy</b></mark> = Wizualne przedstawienie kroków algorytmu w formie bloków (np. start, warunki, operacje).</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/ZlozonoscObliczeniowa.png"><b>Złożoność obliczeniowa</b></mark> = Metryka opisująca, jak zmienia się czas lub pamięć wymagana przez algorytm w zależności od wielkości danych wejściowych.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Rekurencja.png"><b>Rekurencja</b></mark> = Proces, w którym funkcja wywołuje samą siebie, aż osiągnie warunek bazowy.</li>
                    </ul>
                <h2><b>Algorytmy sortujące</b></h2>
                <h3 style="font-size: 17px;">Algorytmy sortujące to metody organizowania elementów w tablicy według określonego porządku (np. rosnąco lub malejąco). Poniżej znajdziesz proste przykłady popularnych algorytmów sortujących w JavaScript.</h3>
                    <ul>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Sortowanie/Bubble.png"><b>Bubble Sort</b></mark> = Algorytm iteracyjnie porównuje sąsiednie elementy i zamienia je miejscami, jeśli są w złej kolejności. Proces powtarza się, aż tablica zostanie posortowana.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Sortowanie/Selection.png"><b>Selection Sort</b></mark> = Algorytm wybiera najmniejszy (lub największy) element z nieposortowanej części tablicy i zamienia go z pierwszym elementem tej części.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Sortowanie/Insertion.png"><b>Insertion Sort</b></mark> = Algorytm buduje posortowaną tablicę, wstawiając każdy element w odpowiednie miejsce w już posortowanej części.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Sortowanie/Merge.png"><b>Merge Sort</b></mark> = Algorytm dzieli tablicę na pół, sortuje każdą część rekurencyjnie, a następnie łączy (scala) je w jedną posortowaną całość.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Sortowanie/Quick.png"><b>QuickSort</b></mark> = Algorytm wybiera element (pivot), dzieli tablicę na dwie części (mniejsze i większe od pivota), a następnie rekurencyjnie sortuje każdą część.</li>
                    </ul>
                <h2><b>Wyszukiwanie binarne</b></h2>
                <h3 style="font-size: 17px;">Wyszukiwanie binarne to efektywny algorytm służący do wyszukiwania konkretnego elementu w posortowanej tablicy. Działa na zasadzie podziału i redukcji, eliminując połowę możliwych elementów przy każdym kroku.</h3>
                <ol>
                    <li>Znajdź element środkowy w tablicy.</li>
                    <li>Porównaj poszukiwany element z elementem środkowym:
                        <ul>
                            <li>Jeśli są równe, znaleziono element.</li>
                            <li>Jeśli poszukiwany element jest mniejszy od środkowego, przeszukaj lewą połowę tablicy.</li>
                            <li>Jeśli poszukiwany element jest większy od środkowego, przeszukaj prawą połowę tablicy.</li>
                        </ul>
                    </li>
                    <li>Powtarzaj kroki aż do znalezienia elementu lub do wyczerpania tablicy.</li>
                </ol>
                <h2><b>Algorytm szyfrujący ROT-13</b></h2>
                <h3 style="font-size: 17px;">ROT-13 (skrót od "rotate by 13 places") to prosty algorytm szyfrujący, który przesuwa każdą literę w alfabecie o 13 pozycji. Jest to odmiana szyfru cezara, ale z przesunięciem wynoszącym dokładnie połowę alfabetu (13 liter).</h3>
                <br><mark class="hover-target" data-image="Images/Algorytmy/ROT13.png"><b>Jak działa</b></mark>
                <ol>
                    <li>
                        <b>Dla każdej litery tekstu:</b>
                        <ul>
                            <li>Zamienia ją na kod ASCII (funkcja <code>charCodeAt</code>).</li>
                            <li>Sprawdza, czy jest to litera (mała lub wielka).</li>
                            <li>Przesuwa kod ASCII o 13 pozycji, uwzględniając zakres alfabetu (<code>% 26</code> zapewnia, że nie wyjdzie poza alfabet).</li>
                        </ul>
                    </li>
                    <li><b>Pozostałe znaki:</b> (np. spacje, cyfry, symbole) pozostają niezmienione.</li>
                    <li><b>Łączy przetworzone litery:</b> z powrotem w ciąg tekstu.</li>
                </ol>
                <h2><b>Algorytmy heurystyczne</b></h2>
                <h3 style="font-size: 17px;">Algorytmy heurystyczne to metody rozwiązywania problemów, które wykorzystują przybliżone rozwiązania, aby znaleźć „wystarczająco dobre” odpowiedzi w krótkim czasie, szczególnie w przypadkach, gdy dokładne rozwiązanie jest trudne lub czasochłonne do obliczenia.</h3>
                <br><mark class="hover-target" data-image="Images/Algorytmy/heurystyczny.png"><b>Przykłady algorytmów heurystycznych</b></mark>
                <ul>
                    <li>
                        <strong>Algorytm zachłanny</strong>
                        <ul>
                            <li>Rozwiązanie budowane jest krok po kroku, zawsze wybierając lokalnie najlepszą opcję (np. najtańszą lub najszybszą).</li>
                            <li>Przykład: Szukanie najkrótszej drogi w grafie z wyborem najbliższego wierzchołka.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Algorytmy metaheurystyczne</strong>
                        <ul>
                            <li>Są bardziej ogólne i mogą być stosowane do różnych problemów.</li>
                            <li>Przykłady:
                                <ul>
                                    <li><strong>Algorytm genetyczny:</strong> Symuluje proces ewolucji, aby znaleźć dobre rozwiązania.</li>
                                    <li><strong>Symulowane wyżarzanie (Simulated Annealing):</strong> Symuluje proces chłodzenia metalu, aby znaleźć optymalne rozwiązanie w skomplikowanej przestrzeni rozwiązań.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Heurystyki w problemie komiwojażera</strong>
                        <ul>
                            <li>Komiwojażer musi odwiedzić określone miasta i wrócić do punktu wyjścia, minimalizując przebytą drogę.</li>
                            <li>Heurystyka: Zawsze wybiera najbliższe nieodwiedzone miasto.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div id="ProjektowanieKlas">
            <h1>Projektowanie klas (UML)</h1>
            <div>
                <h2><b>Co to jest projektowanie klas (UML)?</b></h2>
                <h3 style="font-size: 17px;"><b>Projektowanie klas w UML (ang. Unified Modeling Language)</b> to proces wizualnego modelowania struktury systemu za pomocą diagramów klas. Diagram klas jest jedną z kluczowych części UML i służy do przedstawienia:</h3>
                <ul>
                    <li>Struktury klas w systemie</li>
                    <li>Ich atrybutów (danych przechowywanych przez klasy)</li>
                    <li>Metod (funkcjonalności klas)</li>
                    <li>Zależności pomiędzy klasami (relacji)</li>
                </ul>
                <h2><mark class="hover-target" data-image="Images/Projektowanie_klas_UML/diagram.png"><b>Elementy diagramu klas UML</b></mark></h2>
                <ul>
                    <li>
                        <b>Klasa</b>
                        <ul>
                            <li>Reprezentuje obiekt w systemie.</li>
                            <li>Składa się z trzech sekcji:
                                <ul>
                                    <li>Nazwa klasy,</li>
                                    <li>Atrybuty (dane przechowywane w klasie),</li>
                                    <li>Operacje/metody (funkcje wykonywane przez klasę).</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>Relacje między klasami</b>
                        <ul>
                            <li><b>Dziedziczenie (Inheritance):</b> Kiedy jedna klasa dziedziczy atrybuty i metody innej klasy.</li>
                            <li><b>Asocjacja:</b> Związek logiczny między dwiema klasami (np. "Samochód ma kierowcę").</li>
                            <li><b>Kompozycja:</b> Silniejsza forma asocjacji; obiekt jednej klasy jest częścią składową innego obiektu (np. "Silnik jest częścią samochodu").</li>
                            <li><b>Agregacja:</b> Luźniejsza forma relacji typu „całość-część” (np. "Flota składa się z samochodów").</li>
                        </ul>
                    </li>
                    <li>
                        <b>Widoczność atrybutów i metod</b>
                        <ul>
                            <li><b>+</b> Publiczne: dostępne wszędzie.</li>
                            <li><b>-</b> Prywatne: dostępne tylko w obrębie klasy.</li>
                            <li><b>#</b> Chronione: dostępne w klasie i jej podklasach.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </main>
    <footer>
        <p>© 2024 Filip Rutkowski. Niniejsze dzieło jest udostępniane na licencji (CC BY-NC-ND).</p>
    </footer>
    <div class="hover-image" id="hoverImage">
        <img src="" alt="Hover Image" id="hoverImageContent">
    </div>
    <!--Scripts-->
    <script src="Scripts/scroll.js"></script>
    <script src="Scripts/hoverImageFIX.js"></script>
</body>
</html>