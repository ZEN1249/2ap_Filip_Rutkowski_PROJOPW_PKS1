<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projektowanie aplikacji</title>
    <link rel="shortcut icon" href="Images/Icon/icon.webp" type="image/x-icon"">
    <!--Style-->
    <link rel="stylesheet" href="Style/style.css">
    <link rel="stylesheet" href="Style/nav.css">
    <link rel="stylesheet" href="Style/main.css">
    <link rel="stylesheet" href="Style/footer.css">
    <link rel="stylesheet" href="Style/praktyki.css">
    <link rel="stylesheet" href="Style/cleancode.css">
    <link rel="stylesheet" href="Style/dokumentowaniekodu.css">
    <link rel="stylesheet" href="Style/algorytmy.css">
</head>
<body>
    <nav>
        <ul>
        <button onclick="scrollToSection('Praktyki')">Dobre Praktyki</button>
        <button onclick="scrollToSection('CleanCode')">Clean Code</button>
        <button onclick="scrollToSection('DokumentowanieKodu')">Dokumentowanie kodu</button>
        <button onclick="scrollToSection('Algorytmy')">Algorytmy</button>
        <button onclick="scrollToSection('ProjektowanieKlas')">Projektowanie klas (UML)</button>
        </ul>
    </nav>
    <main>
        <div id="Praktyki">
                <h1>Dobre Praktyki</h1>
            <div id="PraktykiList">
                <ul>
                    <li><mark class="hover-target" data-image="Images/Praktyki/Enkapsulacja.png"><b>Enkapsulacja</b></mark> = Ukrywanie szczegółów implementacji wewnątrz klasy, aby chronić dane przed nieautoryzowanym dostępem. Dzięki temu, dane są bezpieczniejsze, a kod bardziej niezawodny.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Dziedziczenie.png"><b>Dziedziczenie</b></mark> = Umożliwia tworzenie nowych klas na podstawie już istniejących, co pozwala na ponowne wykorzystanie kodu i rozszerzanie funkcjonalności bez jego powtarzania.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Polimorfizm.png"><b>Polimorfizm</b></mark> = Pozwala na definiowanie metod o tej samej nazwie, ale o różnych implementacjach w różnych klasach, zwiększając elastyczność kodu.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/ZasadaJednejOdpowiedzialnosci.png"><b>Zasada Jednej Odpowiedzialności</b></mark> = Klasa powinna odpowiadać tylko za jeden aspekt działania aplikacji, co ułatwia jej zrozumienie i modyfikację.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Odwrocenie_zalezności.png"><b>Odwrócenie zależności</b></mark> = Klasy wyższego poziomu powinny zależeć od abstrakcji, a nie od szczegółów implementacyjnych, co poprawia elastyczność i testowalność.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Interfejsy_i_abstrakcje.png"><b>Interfejsy i abstrakcje</b></mark> = Pozwalają na definiowanie wspólnych zasad działania, które muszą być zaimplementowane przez różne klasy, co ułatwia rozszerzanie kodu.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Unikanie_Dupikacji.png"><b>Unikanie duplikacji kodu</b></mark> = Ważne jest unikanie powtarzania tej samej logiki, ponieważ zmniejsza to złożoność kodu i upraszcza jego utrzymanie.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Testowanie_jednostkowe.png"><b>Testowanie jednostkowe</b></mark> = Pomaga upewnić się, że każda część kodu działa poprawnie i zgodnie z oczekiwaniami, zapewniając stabilność aplikacji.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Projektowanie_rozszerzalnosci.png"><b>Projektowanie z myślą o rozszerzalności</b></mark> = Tworzenie kodu w taki sposób, aby łatwo było dodawać nowe funkcjonalności bez wprowadzania zmian w istniejącej logice.</li>
                    
                    <li><mark class="hover-target" data-image="Images/Praktyki/Loose_Coupling.png"><b>Unikanie zbytniego powiązania klas (Loose Coupling)</b></mark> = Klasy powinny być jak najmniej zależne od siebie, co pozwala na łatwiejsze modyfikacje i testowanie.</li>
                </ul>
            </div>
        </div>
        <div id="CleanCode">
            <h1>Clean Code</h1>
            <div class="card-container">
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>KISS</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Keep It Simple, Stupid" = rozwiązania powinny być proste, unikaj nadmiernej komplikacji.
                            </p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>DRY</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Don't Repeat Yourself" = nie duplikuj kodu; każda informacja w systemie powinna mieć jedno źródło.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>YAGNI</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"You Aren't Gonna Need It" = implementuj tylko te funkcje, które są naprawdę potrzebne, unikaj nadmiernego rozwijania kodu.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>SOLID</p>
                        </div>
                        <div class="flip-card-back">
                            <ul style="font-size: 14px;">
                                <li>S = Single Responsibility Principle</li>
                                <li>O = Open/Closed Principle</li>
                                <li>L = Liskov Substitution Principle</li>
                                <li>I = Interface Segregation Principle</li>
                                <li>D = Dependency Inversion Principle</li>
                            </ul>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>TDD</p>
                        </div>
                        <div class="flip-card-back">
                            <p>"Test-Driven Development" = rozwój oparty na testach; najpierw pisz testy, a potem kod, aby zapewnić jakość i poprawność.</p>
                        </div>
                    </div>
                </div>
            
                <div class="flip-card">
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <p>SRP</p>
                        </div>
                        <div class="flip-card-back">
                            <p style="font-size: 15px;">"Single Responsibility Principle" = zasada jednej odpowiedzialności, czyli każda klasa lub funkcja powinna mieć jedną, jasno określoną odpowiedzialność.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="DokumentowanieKodu">
            <h1>Dokumentowanie Kodu</h1>
            <div>
                <h2><b>Definicja</b></h2>
                <h3 style="font-size: 17px;"><b>Dokumentowanie</b> kodu jest niezwykle ważnym elementem tworzenia oprogramowania, który pomaga programistom (i przyszłym użytkownikom) lepiej zrozumieć, jak działa kod oraz w jaki sposób go używać. Dzięki dobrze napisanej dokumentacji, zrozumienie kodu, jego modyfikacja oraz naprawa ewentualnych błędów stają się o wiele prostsze.</h3>
                <h2><b>Dlaczego warto dokumentować kod?</b></h2>
                <ul>
                    <li><b>Zrozumiałość</b> = Dokumentacja pomaga zrozumieć kod zarówno innym programistom, jak i nam samym w przyszłości, gdy będziemy do niego wracać.</li>
                    <li><b>Łatwiejsze utrzymanie</b> = Ułatwia znalezienie miejsc, które wymagają poprawy lub rozbudowy.</li>
                    <li><b>Przejrzystość</b> = Przejrzysta dokumentacja usprawnia pracę zespołową oraz wdrażanie nowych osób do projektu.</li>
                    <li><b>Profesjonalizm</b> = Dobrze udokumentowany kod świadczy o profesjonalnym podejściu do programowania.</li>
                </ul>
                <h2><b>Rodzaje dokumentacji</b></h2>
                    <ul>
                        <h3><mark class="hover-target" data-image="Images/Dokumentacja/Techniczna.png"><b>Dokumentacja techniczna</b></mark></h3>
                        <li>Dokumentacja API</li>
                        <li>Diagramy UML</li>
                        <li>Opis architektury</li>
                        <li>Instrukcje instalacji i wdrożenia</li>
                        <li>Lista błędów i sposobów ich obsługi</li>
                    </ul>
                    <ul>
                        <h3><mark class="hover-target" data-image="Images/Dokumentacja/Uzytkowa.png"><b>Dokumentacja użytkowa</b></mark></h3>
                            <li>Instrukcje obsługi</li>
                            <li>FAQ</li>
                            <li>Poradniki i tutoriale</li>
                            <li>Przykłady użycia i scenariusze</li>
                            <li>Materiały szkoleniowe</li>
                    </ul>                
            </div>
        </div>
        <div id="Algorytmy">
            <h1>Algorytmy</h1>
            <div>
                <h2><b>Czym jest algorytm?</b></h2>
                <h3 style="font-size: 17px;"><b>Algorytm</b> to skończony zestaw dobrze zdefiniowanych instrukcji lub kroków, które należy wykonać w określonej kolejności, aby rozwiązać problem lub osiągnąć określony cel. Algorytmy są fundamentem programowania i są używane w wielu dziedzinach, takich jak matematyka, informatyka czy automatyka.</h3>
                <h2><b>Projektowanie algorytmu</b></h2>
                    <ul>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Dziel.png"><b>Zasada „dziel i zwyciężaj”</b></mark> = Technika projektowania algorytmów polegająca na podziale problemu na mniejsze podproblemy, rozwiązaniu ich niezależnie, a następnie scaleniu wyników w rozwiązanie główne.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/ListaKrokow.png"><b>Lista kroków</b></mark> = Sekwencja kroków definiująca algorytm w logicznej kolejności.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Pseudokod.png"><b>Pseudokod</b></mark> = Opis algorytmu w zrozumiałej formie, przypominający kod, ale bardziej ogólny.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Drzewo.png"><b>Drzewo decyzyjne</b></mark> = Graficzna reprezentacja algorytmu, opisująca decyzje i ich konsekwencje.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Blokowy.png"><b>Schemat blokowy</b></mark> = Wizualne przedstawienie kroków algorytmu w formie bloków (np. start, warunki, operacje).</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/ZlozonoscObliczeniowa.png"><b>Złożoność obliczeniowa</b></mark> = Metryka opisująca, jak zmienia się czas lub pamięć wymagana przez algorytm w zależności od wielkości danych wejściowych.</li>
                        <li><mark class="hover-target" data-image="Images/Algorytmy/Rekurencja.png"><b>Rekurencja</b></mark> = Proces, w którym funkcja wywołuje samą siebie, aż osiągnie warunek bazowy.</li>
                    </ul>
                <h2><b>Algorytmy sortujące</b></h2>
                <h2><b>Wyszukiwanie binarne</b></h2>
                <h2><b>Algorytm szyfrujący ROT-13</b></h2>
                <h2><b>Algorytmy heurystyczne</b></h2>
            </div>
        </div>
        <div id="ProjektowanieKlas"></div>
    </main>
    <footer>
        <p>© 2024 Filip Rutkowski. Niniejsze dzieło jest udostępniane na licencji (CC BY-NC-ND).</p>
    </footer>
    <div class="hover-image" id="hoverImage">
        <img src="" alt="Hover Image" id="hoverImageContent">
    </div>
    <!--Scripts-->
    <script src="Scripts/scroll.js"></script>
    <script src="Scripts/hoverImageFIX.js"></script>
</body>
</html>